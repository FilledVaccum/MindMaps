<mxfile host="app.diagrams.net" modified="2024-06-25T17:19:40.080Z" agent="Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:126.0) Gecko/20100101 Firefox/126.0" etag="RZrTyEdSCJuM8hMJf4ts" version="24.6.2" type="github">
  <diagram name="Page-1" id="kw6MyCMnG_gdqnyi81Ma">
    <mxGraphModel dx="2726" dy="1788" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="850" pageHeight="1100" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="WSp6ezsUZnpdrh4Umi9b-4" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;hachureGap=4;orthogonalLoop=1;jettySize=auto;html=1;fontFamily=Architects Daughter;fontSource=https%3A%2F%2Ffonts.googleapis.com%2Fcss%3Ffamily%3DArchitects%2BDaughter;fontSize=12;fontColor=default;" edge="1" parent="1" source="WSp6ezsUZnpdrh4Umi9b-1" target="WSp6ezsUZnpdrh4Umi9b-3">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="WSp6ezsUZnpdrh4Umi9b-1" value="&lt;h1 id=&quot;page-title&quot; class=&quot;mb-2 mt-14 text-left text-gray-L800 dark:text-gray-D200 heading-one tracking-tight&quot;&gt;The Sharded Counters&lt;/h1&gt;" style="shape=step;perimeter=stepPerimeter;whiteSpace=wrap;html=1;fixedSize=1;hachureGap=4;fontFamily=Architects Daughter;fontSource=https%3A%2F%2Ffonts.googleapis.com%2Fcss%3Ffamily%3DArchitects%2BDaughter;" vertex="1" parent="1">
          <mxGeometry x="310" y="480" width="220" height="80" as="geometry" />
        </mxCell>
        <mxCell id="WSp6ezsUZnpdrh4Umi9b-2" value="&lt;h2 align=&quot;justify&quot; data-id=&quot;a1b8af0ef88bc9bd8ad46db694c63682&quot; id=&quot;How-will-we-design-sharded-counters&quot; class=&quot;hover-anchor&quot;&gt;How will we design sharded counters?&lt;/h2&gt;&lt;hr align=&quot;justify&quot;&gt;&lt;div align=&quot;justify&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;p align=&quot;justify&quot; style=&quot;font-size: 17px;&quot; data-id=&quot;7dcbdab12ffc111be2ff869309110f0d&quot;&gt;&lt;font style=&quot;font-size: 17px;&quot;&gt;We have divided the design of sharded counters into three lessons:&lt;/font&gt;&lt;/p&gt;&lt;div align=&quot;justify&quot; style=&quot;font-size: 17px;&quot;&gt;&lt;ol data-id=&quot;ddf856992bac2ba73596f2eda9cfec93&quot;&gt;&lt;li&gt;&lt;font style=&quot;font-size: 17px;&quot;&gt;&lt;strong&gt;&lt;a rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot; href=&quot;https://www.educative.io/courses/grokking-modern-system-design-interview-for-engineers-managers/high-level-design-of-sharded-counters&quot;&gt;High-level Design&lt;/a&gt;&lt;/strong&gt;:&lt;br&gt; We’ll discuss the high-level design of sharded counters in this lesson.&lt;br&gt; In addition, we’ll also briefly explain the API design.&lt;/font&gt;&lt;/li&gt;&lt;li&gt;&lt;font style=&quot;font-size: 17px;&quot;&gt;&lt;strong&gt;&lt;a rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot; href=&quot;https://www.educative.io/courses/grokking-modern-system-design-interview-for-engineers-managers/detailed-design-of-sharded-counters&quot;&gt;Detailed Design&lt;/a&gt;&lt;/strong&gt;: This lesson will dive deeply into the design of sharded counters. Moreover, we’ll also evaluate our proposed design.&lt;/font&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;" style="text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;fontFamily=Architects Daughter;fontSource=https%3A%2F%2Ffonts.googleapis.com%2Fcss%3Ffamily%3DArchitects%2BDaughter;fontSize=12;fontColor=default;" vertex="1" parent="1">
          <mxGeometry x="-1320" y="-320" width="1090" height="240" as="geometry" />
        </mxCell>
        <UserObject label="Heavy Hitter Problem" tooltip="The heavy hitters problem, also known as the frequent elements problem, is a common challenge in system design that involves identifying the most frequent or &quot;heavy&quot; elements in a data stream or large dataset. It is particularly relevant in scenarios where data processing systems need to handle massive volumes of data in real-time or near real-time.&#xa;&#xa;The problem can be stated as follows: Given a stream of data elements (e.g., IP addresses, URLs, user IDs, or any other identifiable entities), find the elements that occur most frequently, subject to some constraints or thresholds.&#xa;&#xa;Key aspects of the heavy hitters problem include:&#xa;&#xa;1. **Data Stream**: The input data arrives as a continuous stream, and it may not be feasible to store the entire stream due to memory constraints or real-time processing requirements.&#xa;&#xa;2. **Space Efficiency**: The solution should use a limited amount of memory, ideally much smaller than the size of the input data stream.&#xa;&#xa;3. **Approximation**: In many cases, an approximate solution is acceptable, as long as it provides a good estimate of the most frequent elements within a specified error bound.&#xa;&#xa;4. **Threshold or Top-k**: The problem may involve finding elements that occur more than a certain threshold (e.g., 1% of the total occurrences) or the top-k most frequent elements (e.g., the top 100 most frequent URLs).&#xa;&#xa;The heavy hitters problem has various applications in system design, including:&#xa;&#xa;1. **Network Monitoring**: Identifying the most frequently accessed websites, IP addresses, or network traffic patterns for security, load balancing, or traffic engineering purposes.&#xa;&#xa;2. **Web Analytics**: Tracking the most popular web pages, user activities, or user behavior patterns for content optimization, personalization, or targeted advertising.&#xa;&#xa;3. **Fraud Detection**: Identifying unusual or suspicious patterns in transaction data, such as frequent occurrences of certain account numbers or IP addresses, which may indicate fraudulent activities.&#xa;&#xa;4. **Database Optimization**: Identifying frequently accessed data patterns or hot spots to optimize query performance, caching, or data partitioning strategies.&#xa;&#xa;Several algorithms have been developed to solve the heavy hitters problem efficiently, including:&#xa;&#xa;1. **Counting Algorithms**: These algorithms maintain a data structure (e.g., a hash table or a tree) to keep track of the frequencies of elements and prune or approximate the less frequent ones.&#xa;&#xa;2. **Sketching Algorithms**: These algorithms use probabilistic data structures, such as Count-Min Sketch or Count Sketch, to estimate the frequencies of elements with bounded error guarantees.&#xa;&#xa;3. **Sampling Techniques**: These techniques involve sampling a subset of the input data and extrapolating the frequent elements from the sample, often combined with other algorithms for improved accuracy.&#xa;&#xa;The choice of algorithm and implementation details depends on factors such as the desired accuracy, memory constraints, update rates, and the specific requirements of the system." id="WSp6ezsUZnpdrh4Umi9b-3">
          <mxCell style="ellipse;whiteSpace=wrap;html=1;fontFamily=Architects Daughter;hachureGap=4;fontSource=https%3A%2F%2Ffonts.googleapis.com%2Fcss%3Ffamily%3DArchitects%2BDaughter;" vertex="1" parent="1">
            <mxGeometry x="70" y="330" width="80" height="80" as="geometry" />
          </mxCell>
        </UserObject>
        <UserObject label="What is Heavy Hitter Problem?&lt;br&gt;" tooltip="The heavy hitters problem, also known as the frequent elements problem, is a common challenge in system design that involves identifying the most frequent or &quot;heavy&quot; elements in a data stream or large dataset. It is particularly relevant in scenarios where data processing systems need to handle massive volumes of data in real-time or near real-time.&#xa;&#xa;The problem can be stated as follows: Given a stream of data elements (e.g., IP addresses, URLs, user IDs, or any other identifiable entities), find the elements that occur most frequently, subject to some constraints or thresholds.&#xa;&#xa;Key aspects of the heavy hitters problem include:&#xa;&#xa;1. **Data Stream**: The input data arrives as a continuous stream, and it may not be feasible to store the entire stream due to memory constraints or real-time processing requirements.&#xa;&#xa;2. **Space Efficiency**: The solution should use a limited amount of memory, ideally much smaller than the size of the input data stream.&#xa;&#xa;3. **Approximation**: In many cases, an approximate solution is acceptable, as long as it provides a good estimate of the most frequent elements within a specified error bound.&#xa;&#xa;4. **Threshold or Top-k**: The problem may involve finding elements that occur more than a certain threshold (e.g., 1% of the total occurrences) or the top-k most frequent elements (e.g., the top 100 most frequent URLs).&#xa;&#xa;The heavy hitters problem has various applications in system design, including:&#xa;&#xa;1. **Network Monitoring**: Identifying the most frequently accessed websites, IP addresses, or network traffic patterns for security, load balancing, or traffic engineering purposes.&#xa;&#xa;2. **Web Analytics**: Tracking the most popular web pages, user activities, or user behavior patterns for content optimization, personalization, or targeted advertising.&#xa;&#xa;3. **Fraud Detection**: Identifying unusual or suspicious patterns in transaction data, such as frequent occurrences of certain account numbers or IP addresses, which may indicate fraudulent activities.&#xa;&#xa;4. **Database Optimization**: Identifying frequently accessed data patterns or hot spots to optimize query performance, caching, or data partitioning strategies.&#xa;&#xa;Several algorithms have been developed to solve the heavy hitters problem efficiently, including:&#xa;&#xa;1. **Counting Algorithms**: These algorithms maintain a data structure (e.g., a hash table or a tree) to keep track of the frequencies of elements and prune or approximate the less frequent ones.&#xa;&#xa;2. **Sketching Algorithms**: These algorithms use probabilistic data structures, such as Count-Min Sketch or Count Sketch, to estimate the frequencies of elements with bounded error guarantees.&#xa;&#xa;3. **Sampling Techniques**: These techniques involve sampling a subset of the input data and extrapolating the frequent elements from the sample, often combined with other algorithms for improved accuracy.&#xa;&#xa;The choice of algorithm and implementation details depends on factors such as the desired accuracy, memory constraints, update rates, and the specific requirements of the system." id="WSp6ezsUZnpdrh4Umi9b-6">
          <mxCell style="shape=note;backgroundOutline=1;fontColor=#000000;darkOpacity=0.05;fillColor=#FFF9B2;strokeColor=none;fillStyle=solid;direction=west;gradientDirection=north;gradientColor=#FFF2A1;shadow=1;size=20;pointerEvents=1;hachureGap=4;align=center;verticalAlign=middle;fontFamily=Comic Sans MS;fontSize=12;labelBackgroundColor=none;labelBorderColor=none;html=1;whiteSpace=wrap;horizontal=1;" vertex="1" parent="1">
            <mxGeometry x="-200" y="-280" width="250" height="40" as="geometry" />
          </mxCell>
        </UserObject>
        <mxCell id="WSp6ezsUZnpdrh4Umi9b-7" value="&lt;font style=&quot;font-size: 14px;&quot;&gt;What is lock Contention?&lt;br&gt;&lt;/font&gt;" style="shape=note;whiteSpace=wrap;html=1;backgroundOutline=1;fontColor=#000000;darkOpacity=0.05;fillColor=#FFF9B2;strokeColor=none;fillStyle=solid;direction=west;gradientDirection=north;gradientColor=#FFF2A1;shadow=1;size=20;pointerEvents=1;hachureGap=4;align=center;verticalAlign=middle;fontFamily=Architects Daughter;fontSource=https%3A%2F%2Ffonts.googleapis.com%2Fcss%3Ffamily%3DArchitects%2BDaughter;fontSize=12;labelBackgroundColor=none;" vertex="1" parent="1">
          <mxGeometry x="-200" y="-200" width="240" height="40" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
